# TrussPhoto Vision

## コンセプト

TrussPhotoは「写真と向き合う方法を多様化する」アプリ。
Lightroom互換の現像品質を保ちつつ、写真を個人的な意味のノードとして扱う。

写真アプリは「撮影日・場所・アルバム」という軸しか持たないが、
人が写真を振り返る時の思考はもっと多次元的:
- 「あの時と似た空気感だった」
- 「この人とはあの旅行でも一緒だった」
- 「この頃こういうことを考えてた」

これらを表現・探索できる仕組みを作る。

## 柱となる機能

### 1. セルフホストサーバ連携
クラウドサービスにデータを握られない。自分のサーバに全データを置き、
ネイティブアプリと連携する。既に基本的な同期・アップロード機能は実装済み。

### 2. リッチメタデータ
写真にテキスト・メモ・音声などを紐付ける。
日記アプリでは日記が主で写真が従、写真アプリではテキストが扱えない。
TrussPhotoではテキストが写真のメタデータとして対等に存在する。

- **メモ**: Markdown形式のフリーテキスト
- **アノテーション**: 写真上の位置に紐づくコメント（吹き出し表示）
- **タグ**: ユーザ定義 + AI生成
- **会話ログ**: AIとの対話履歴の要約

### 3. ベクトル埋め込み（embedding）による関連性
写真とテキストをベクトル空間に埋め込み、意味的な近さで結ぶ。
時系列やアルバムでは表せない関係性を発見する。

- 「時間も場所も違うけど、似た雰囲気の写真」
- 「このメモに関連する写真」
- ワードクラウド的な可視化（ベクトル空間の2D射影）

### 4. AIとの対話（MCP）
MCP機能を通じてAIと写真について語り合う。
会話の結果がメタデータに蓄積され、写真のコンテキストが育っていく。

「写真と語り合う」感覚。使うほど写真が豊かになるループ。

### 5. 現像品質の維持
体験の起点は「いい画を見る」こと。
RAWパイプライン（LibRaw → レンズ補正 → LUT）を土台として維持する。

### 6. tcxRivet（UIフレームワーク）
TrussC用の本格的なUIアドオン。レイアウトシステム、ウィジェット群（ボタン、
スライダー、スクロール、分割ペイン等）を提供し、TrussPhoto含むTrussCアプリ
共通のUI基盤となる。現在は TrussC の Node システムで直接構築しているが、
将来的に tcxRivet に移行することでUIの表現力と開発効率を上げる。

---

## アプリケーションアーキテクチャ

### 1バイナリ、2モード

TrussPhoto と TrussPhotoServer を **1つのバイナリに統合** する。
サーバ機能は常に内蔵され、起動モードで振る舞いが変わる。

```
TrussPhoto                          → GUIモード（UI + 内蔵サーバ）
TrussPhoto --server                 → サーバモード（ヘッドレス、HTTPのみ）
TrussPhoto --remote 192.168.1.100   → リモートモード（UI、外部サーバ接続）
```

**メリット:**
- 現像パイプライン等のコード重複がゼロ
- ローカルでもリモートでも同じ API 抽象レイヤー経由でアクセス
- サーバ移行は data/ ディレクトリをコピーするだけ

### API 抽象レイヤー (PhotoApi)

クライアントコードはモードを意識せず `PhotoApi` を通じてデータにアクセスする。
モードによって実体が切り替わる:

```
PhotoApi (interface)
├── LocalApi   → 同一プロセス内で関数呼び出し（GUIモード）
└── RemoteApi  → HTTP リクエスト経由（リモートモード）
```

**GUIモードではポートを一切使わない。** Crow HTTP サーバはサーバモードの時だけ起動する。
これによりポート競合が発生しない。

サーバモードのポートはデフォルト 18730（設定変更可能）:
```json
// server_config.json
{"port": 18730, "apiKey": "..."}
```

### コード構成

```
TrussPhoto/src/
├── PhotoApi.h          ← API 抽象インターフェース
├── LocalApi.h          ← 直接呼び出し実装（GUIモード用）
├── RemoteApi.h         ← HTTP 実装（リモートモード用）
├── PhotoServer.h       ← サーバ機能（サムネ生成、DB管理、Crow ルート定義）
├── 共通: RAWパイプライン, メタデータ, SQLite, サムネ/プレビュー生成
├── GUIモード: UI描画, ユーザ操作
└── main.cpp: --server / --remote フラグで分岐
```

### 動作モード詳細

**GUIモード（デフォルト）:**
- PhotoServer をインスタンス化（Crow は起動しない）
- LocalApi 経由で直接アクセス（関数呼び出し、オーバーヘッドゼロ）
- RAW ドロップ → 直接 data/originals/ に保存（アップロード不要）

**サーバモード (`--server`):**
- PhotoServer + Crow HTTP サーバ起動、UI なし
- Linux サーバで常時稼働を想定
- 外部クライアントからの接続を受け付ける

**リモートモード (`--remote <host>`):**
- Crow もローカル PhotoServer も起動しない
- RemoteApi 経由で HTTP リクエスト
- サムネ/プレビューはローカルにキャッシュ
- RAW ドロップ → pending/ に一時保存 → サーバにアップロード

### サーバ移行

```
Phase 1: デスクトップ1台で始める（GUIモード）
  → data/ に RAW 含め全部入ってる

Phase 2: サーバを立てたくなった
  → data/ をまるごとサーバ機にコピー
  → サーバ機で TrussPhoto --server
  → デスクトップで TrussPhoto --remote <server>
  → ローカルの data/ は削除可能（サーバにある）
```

---

## データ権威モデル: ローカルファースト

### 権威の分離

「人間が触るデータ」と「機械が生成するデータ」で権威を分ける:

| データ種別 | 権威 | 例 |
|-----------|------|-----|
| 人間が編集 | クライアント | メモ、タグ、レーティング、アノテーション |
| 機械が生成 | サーバ | embedding、AIタグ、サムネイル、スマートプレビュー |
| 写真ファイル | サーバ | RAW オリジナル（GUIモードではローカル = サーバ） |

### マルチクライアント同期

フィールド単位の `updatedAt` で last-write-wins:

```sql
CREATE TABLE photos (
    id TEXT PRIMARY KEY,
    ...
    memo TEXT,
    memo_updatedAt INTEGER,
    tags TEXT,
    tags_updatedAt INTEGER,
    rating INTEGER,
    rating_updatedAt INTEGER,
    ...
);
```

2つのクライアントが同じ写真の **別フィールド** を編集しても、
両方の変更が生き残る。同じフィールドの同時編集だけ後勝ち
（個人用途でほぼ起きない）。

### 同期フロー

```
1. クライアント → サーバ: lastSync 以降の変更を送信
2. サーバ: フィールドごとに updatedAt を比較、新しい方を採用
3. サーバ → クライアント: サーバ側の変更（embedding, AIタグ等）を返却
4. クライアント: 受け取って DB を更新
5. 両方の lastSync を更新
```

---

## 3段階プレビューシステム

| 段階 | 解像度 | 形式 | 生成者 | 用途 |
|------|--------|------|--------|------|
| サムネイル | 512px | JPEG | サーバ（最終版）/ クライアント（つなぎ） | グリッド表示 |
| スマートプレビュー | 2560px | JPEG XL 12bit | サーバ | 単一表示、軽い現像 |
| フルサイズ | オリジナル | RAW | - | 本格編集、最終書き出し |

### サムネイルの段階的アップグレード

```
1. RAW ドロップ → クライアントが即席サムネ生成（embedded JPEG 抽出）
   → ユーザーはすぐグリッドで見れる
2. RAW をサーバにアップロード（リモートモード時）
3. サーバが正式サムネ生成（現像パイプライン適用）
4. 次の同期でクライアントがサーバのサムネに差し替え
```

判定: サーバにサムネがあればそれを使う。なければローカルのフォールバック。

### 形式の選定理由

- **サムネイル = JPEG**: グリッドで大量にデコードするため速度重視。stb_image で完結。
  JPEG XL はデコード速度が約5-10倍遅く、512px では圧縮率の差も小さい
- **スマートプレビュー = JPEG XL**: 12bit 広色域、デモザイク後の高品質リサイズ。
  1枚ずつ開くのでデコード速度は問題にならない。DNG（モザイク保持）も検討したが、
  Linux サーバでの DNG 書き出しライブラリが限られるため JPEG XL を選択
- **フルサイズ = RAW**: 常にオリジナルを保持。最終出力はここから

---

## ファイル配置

### プラットフォーム別パス

アプリ固有のパス (`tpDataPath`, `tpCachePath`) を `#ifdef` で定義:

| OS | tpDataPath (永続、消失不可) | tpCachePath (再生成可能) |
|----|---------------------------|------------------------|
| macOS | `~/Library/Application Support/TrussPhoto/` | `~/Library/Caches/TrussPhoto/` |
| Linux | `~/.local/share/TrussPhoto/` | `~/.cache/TrussPhoto/` |
| Windows | `%APPDATA%/TrussPhoto/` | `%LOCALAPPDATA%/TrussPhoto/` |

`bin/data/` は引き続きバンドルリソース（lensfun DB 等、読み取り専用）に使用。

### GUIモード（内蔵サーバ）

```
tpDataPath/
├── settings.json
├── data/                       ← サーバの data/ そのもの
│   ├── library.db              ← SQLite（メタデータ + embedding）
│   ├── server_config.json
│   ├── originals/              ← RAW（日付別）
│   │   └── 2024/01/15/
│   │       └── DSC00001.ARW
│   ├── thumbnails/             ← 512px JPEG（サーバ生成）
│   └── smart_previews/         ← 2560px JPEG XL（サーバ生成）
```

### リモートモード

```
tpDataPath/
├── settings.json               ← 接続先、APIキー
├── local.db                    ← ローカル状態（pending 管理等）
└── pending/                    ← アップ待ちRAW（消失不可）
    └── DSC00001.ARW

tpCachePath/
├── thumbnails/                 ← サーバからDL（消えても再DL可能）
└── smart_previews/             ← サーバからDL（消えても再DL可能）
```

---

## メタデータアーキテクチャ

### 二層構造

```
DB (SQLite)                        XMP サイドカー (.xmp)
━━━━━━━━━━━━━━━━━━━              ━━━━━━━━━━━━━━━━━━━
日常的なソースオブトゥルース          ポータブルなエクスポート形式
検索・関連性・高速アクセス            RAWがある場所に生成
━━━━━━━━━━━━━━━━━━━              ━━━━━━━━━━━━━━━━━━━

全メタデータ                        Lightroom互換フィールド
ベクトル embedding                   dc:description (メモ+アノテーション)
写真間のリレーション                  dc:subject (タグ)
会話ログ全文                         xmp:Rating, xmp:Label
検索インデックス
```

### 原則

- **DBが正**: アプリが常に使うのはDB
- **XMPはエクスポート**: RAWがローカルにある写真にはサイドカーを生成
- **XMPはインポート可能**: XMP付きファイルを読み込めばDBに取り込む
- **RAWファイル自体には書き込まない**: サイドカー専用（破損リスク回避）
- **DBは再構築可能**: XMPサイドカー + RAW があればDBは再生成できる
- **脱出可能**: RAWダウンロード + XMPバッチ生成で全情報を持ち出せる

### XMP内のフォーマット

`dc:description` にメモ・アノテーション・タグを集約。
テキストとして読んでも意味がわかる形式:

```
朝焼けがすごく綺麗だった。前回(2024年夏)と同じ場所から撮影。

[pin 0.35,0.72] ここの光が好き
[pin 0.80,0.20] 雲の形が面白い

#旅行 #朝焼け #山
```

- 冒頭のフリーテキスト = メモ本文（Markdown可）
- `[pin x,y]` = 位置付きアノテーション（正規化座標）
- `#tag` = タグ（`dc:subject` にも同期してLightroomのキーワードになる）
- Lightroomで見たら普通のキャプションとして読める

### データの流れ

```
ローカルにRAWがある写真:
  編集 → DB更新 + XMPサイドカー書き出し

ServerOnlyの写真:
  DBだけで管理、XMPは不要

Lightroomへの移行:
  RAWダウンロード + XMPバッチ生成

XMP付きファイルのインポート:
  XMPパース → DB取り込み
```

---

## ベクトル埋め込み

### モデル選定

CLIP系を使用。画像とテキストを同一空間に埋め込める。

| モデル | サイズ | 次元数 | 備考 |
|--------|--------|--------|------|
| ViT-B/32 | 150MB | 512 | 軽量、CPU実用的。まずはこれで開始 |
| ViT-B/16 | 300MB | 512 | バランス型 |
| ViT-L/14 | 900MB | 768 | 高品質 |

- ローカルで動作（APIに依存しない、セルフホストの思想に合致）
- サーバモードで生成（ONNX Runtime C++ API）
- C++スタック統一: tcxOnnx アドオンとして実装、Crow サーバ内で直接推論
- i5-12400 CPUで ViT-B/32: ~100-200ms/枚、10万枚で数時間（初回のみ）

### DB設計

```sql
CREATE TABLE embeddings (
    photo_id TEXT,
    model    TEXT,       -- "clip-vit-b32"
    source   TEXT,       -- "image", "memo", "conversation"
    vector   BLOB,       -- float[] をそのまま格納
    PRIMARY KEY (photo_id, model, source)
);
```

- 1枚の写真に画像由来・メモ由来・会話由来の複数ベクトルを持てる
- モデル更新時は旧ベクトルを残したまま新モデルのベクトルを追加
  - 再生成中も旧モデルで検索可能
  - 移行完了後に旧モデルのベクトルを削除
- sqlite-vss でベクトル検索インデックス

### 検索の仕組み

- 類似画像検索: 写真のベクトル同士のコサイン類似度
- テキスト→画像検索: テキストをCLIPでベクトル化 → 画像ベクトルと比較
- 関連写真発見: embedding空間上の近傍探索
- 可視化: t-SNE/UMAPで2D射影 → インタラクティブな探索UI

---

## 技術スタック（将来）

| 領域 | 技術 |
|------|------|
| DB | SQLite（library.jsonから移行） + sqlite-vss |
| XMP読み書き | exiv2（既に導入済み、現在は読み取りのみ） |
| embedding生成 | ONNX Runtime C++ API (tcxOnnx アドオン) |
| スマートプレビュー | libjxl (JPEG XL 12bit) |
| HTTPサーバ | Crow（内蔵、全モード共通） |
| MCP | 既存MCP基盤を拡張 |
| UI | tcxRivet（TrussC UIアドオン、将来） |

---

## 実装の優先順位（暫定）

1. ~~**SQLite移行**~~: ✅
2. ~~**1バイナリ統合**~~: ✅
3. ~~**リッチメタデータ + XMP**~~: ✅
4. ~~**スマートプレビュー**~~: ✅ (XYB float16, d=2.0)
5. ~~**embedding基盤 (CLIP)**~~: ✅ (SigLIP2 768-dim)
6. ~~**顔検出 (InsightFace)**~~: ✅ (SCRFD + ArcFace)
7. **ベクトル検索改善** ← 現在
8. **MCP拡張**
9. **可視化UI**: ベクトル空間の2D射影、クラスタ表示
10. **tcxRivet**: UIフレームワーク（TrussPhoto専用ではなく TrussC 共通アドオン）

## TODO（機能追加・優先順）

### P1: 人物・顔
- [ ] **人物ビュー（People）**: 顔が誰か設定するUI
  - 前セッションで詳細設計を議論済み

### P2: 現像・画像処理
- [ ] **現像機能**: まず露光とホワイトバランスから。sokol-shdc で GLSL シェーダを書く
  - プレビューはローカルマシン限定（GPU シェーダはヘッドレスで動かせない）
- [ ] **カラーマネージメント**: 半分実装済み、データがまだない
  - データの所有者を決める（サーバ？ユーザ？アプリ固定？）

### P3: コレクション・インポート
- [ ] **Lightroom コレクション再現**: LR DB からコレクション + スマートコレクションをインポート
  - コレクション（手動振り分け）が先、スマートコレクション（条件ベース）は後
- [ ] **仮想コピー**: Lightroom DB からインポートしたデータを正しく表示

### P4: その他
- [ ] **動画再生機能**
- [ ] **検索対象にファイル種別フィルター**: 動画 / 静止画 / 全て を選択可能に
- [ ] **右クリックメニュー（コンテキストメニュー）**: アプリ全体で統一的に使える仕組み
  - 右クリック時にイベントをブロードキャスト → 各オブジェクトがヒット判定してメニュー項目を登録
  - ヒットしてなくても常駐メニュー項目を出したいオブジェクトも対応
- [ ] **メニューバー（ファイルメニュー等）**: macOS ネイティブ or 独自描画
- [ ] **設定画面**: Cmd+, で開く環境設定ダイアログ
- [ ] **マップ: タイムライン表示**: マップビュー下部に写真タイムラインを1列表示
- [ ] **マップ: ジオタグ手動登録**: マップ上でジオタグを手動設定
- [ ] **マップ: ジオタグ有無の可視化**: タイムライン上の写真にジオタグ有無で枠色を変える
- [ ] **マップ: ピンのクラスタリング**: 重なるピンをまとめて枚数を数字で表示
